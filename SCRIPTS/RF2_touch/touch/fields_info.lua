return {configurationFeatures = { t="Features", help="<strong>Note:</strong> Not all features are supported by all flight controllers. If you enable a specific feature, and it is disabled after you hit 'Save and Reboot', it means that this feature is not supported." },
configurationSerialPorts = { t="Serial Ports", help="Select function and speed for each serial port (UART)." },
configurationRSSI = { t="RSSI (Signal Strength)", help="RSSI is a measurement of signal strength and is very handy so you know when your aircraft is going out of range or if it is suffering RF interference." },
configurationBoardAlignment = { t="Board and Sensor Alignment", help="Arbitrary board rotation allows mounting the FC sideways / upside down / rotated etc. When using external sensors, use the sensor alignments to define sensor position independent from the board orientation." },
configurationBoardAlignmentRoll = { t="Roll Degrees", help="Arbitrary board rotation allows mounting the FC sideways / upside down / rotated etc. When using external sensors, use the sensor alignments to define sensor position independent from the board orientation." },
configurationBoardAlignmentPitch = { t="Pitch Degrees", help="Arbitrary board rotation allows mounting the FC sideways / upside down / rotated etc. When using external sensors, use the sensor alignments to define sensor position independent from the board orientation." },
configurationBoardAlignmentYaw = { t="Yaw Degrees", help="Arbitrary board rotation allows mounting the FC sideways / upside down / rotated etc. When using external sensors, use the sensor alignments to define sensor position independent from the board orientation." },
configurationAccelTrims = { t="Accelerometer Trim", help="The Accelerometer Trims provide fine tuning to the horizon level, which can be used to decrease drift while in stabilized modes, such as Angle or Rescue." },
configurationBeeper = { t="Buzzer Configuration", help="Enable or disable when to sound the Buzzer" },
configurationGPSGalileo = { t="Use Galileo", help="When enabled, this removes the QZSS system (Japanese) and replaces it for the Galileo system (European)." },
configurationGPSHomeOnce = { t="Set Home Point Once", help="When enabled, only the first arm after the battery is connected will be used as home point. If not enabled, every time the quad is armed, the home point will be updated." },
profilesProportional = { t="Proportional", help="Controls the strength of how tightly the machine tracks the sticks (the Setpoint) and corrects for external influences.<br /><br />Higher value (gains) provide tighter tracking, but can cause overshoot if too high in proportion to the derivative (D-gain). Think of the P-term as the spring on a car." },
profilesIntegral = { t="Integral", help="Controls the strength of how tightly the machine holds the overall rotation rate setpoint.<br>Similar to Proportional, but for longer biases on the craft from the rotation rate setpoint, as well as persistent outside influence, for example steady wind or CG offsets.<br /><br />Higher gains provide tighter tracking of the setpoint (i.e. in constant flips and rolls), but can lead to the craft now being able to follow the setpoint on extremely quick inputs, which can lead to it continuing to rotate after the stick is released. <br>If extremely high in proportion to the D-term, can cause oscillations." },
profilesDerivative = { t="Derivative", help="Controls the strength of damping ANY angular acceleration of the craft, whether from stick inputs or external influences. For stick inputs, the D-term damps the movement to prevent overshooting. For an outside influence (vorticity or wind gust) the D-term damps the disturbance.<br /><br />Higher gains provide more damping and reduce possible overshoot from high P-terms.<br>However, the D-term is VERY sensitive to high frequency gyro vibrations (noise | magnifies by 10x to 100x).<br /><br />High frequency noise in the control loop can cause excessive servo heat and burn out servos if the gyro noise is not filtered properly (see Gyro tab).<br /><br />Think of the D-term as the shock absorber on your car, but with the inherent negative property of magnifying high frequency gyro noise." },
profilesFeedforward = { t="Feedforward", help="This is an additional pushing term based on stick input. FF helps the P-term push the craft for commanded stick moves, does not react to any helicopter movements though.<br /><br />The FF-term pushes based on the difference between the commanded Setpoint (deg/sec). <br /><br />Higher values (gains) will result in a sharper response to stick input.<br>Too high of values may result in overshoot, as well as strikeback at the end of control inputs.<br>Too low or zero (0) values will result in a slow and delayed response to stick inputs, as well as continued rotation after the stick is released." },
profilesBoost = { t="Boost", help="This is an additional boost on the feedforward, based on the derivative of the setpoint. An increase of Boost can make the model's reaction sharper, without he drawbacks of high Proportional or Feedforward gains." },
receiverBars = { t="Receiver Channels", help="Shows the raw RC channels from the receiver exactly the way they are received. Please select the channel map, i.e. the corrent function for each RC channel." },
servoMid = { t="Center", help="Center position in us. The servo arm should be level in this position." },
servoMin = { t="Min", help="Lowest point of travel (minimum pulse width). This setting changes the allowed negative servo throw. It is used for avoiding servo arm binding at the negative travel extreme." },
servoMax = { t="Max", help="Highest point of travel (maximum pulse width). This setting changes the allowed positive servo throw. It is used for avoiding servo arm binding at the positive travel extreme." },
servoScaleNeg = { t="Scale neg", help="Scaling factor on the negative side. Typically 500us for normal (1520us) servos, and 250us for narrow band (760us) servos. Altering this setting from the default is used for correcting any nonlinearity between the negative and positive throws." },
servoScalePos = { t="Scale pos", help="Scaling factor on the positive side. Typically 500us for normal (1520us) servos, and 250us for narrow band (760us) servos. Altering this setting from the default is used for correcting any nonlinearity between the negative and positive throws." },
servoRate = { t="Rate [Hz]", help="PWM update rate in Hz. For analog servos, set it to 50Hz, as higher values can cause damage. For digital servos, values from 100Hz to 560Hz are typical. Please check the servo data sheet.<br><b>Note</b>: Select <i>Save and reboot</i> to actually change the update rate, as the rate is initialised at boot time.", units="Hz" },
servoSpeed = { t="Speed [ms]", help="Limits the servo motion speed. Can be used for e.g. retracts. A value of 0 means no limitation. Values between 1-60000 milliseconds specify the time needed for 60deg rotation.", units="ms" },
servoReverse = { t="Reverse", help="Reverse the servo if it's not moving in the right direction." },
servoGeometryCorrection = { t="Geo cor", help="Enable <i>Geometry Correction</i> for correcting the rotational geometry at the servo movement extremes. Do not use with linear servos." },
servoOverride = { t="Servo Override", help="Select the servo to be controlled and then move the slider to move the servo arm to the commanded angle." },
mixerMainRotorDirection = { t="Main Rotor Direction", help="Looking from the top of the helicopter, what direction is the main rotor turning? For the majority of helicopters this is clockwise." },
mixerSwashType = { t="Swashplate Type", help="<strong>None:</strong> The mixer is disabled. Custom mixing rules must be set in the CLI. <br><br><strong>Direct:</strong> No mixing, controls are passed through the mixer unchanged for external mixing.<br><br><strong>CCPM:</strong> Cyclic-Collective Pitch Mixing. For cyclic-pitch helicopters with three swashplate servos, at 120deg, 135deg, or 140deg angle.<br><br><strong>FPM:</strong> Fixed Pitch Mixing. For fixed-pitch helicopters with two swashplate servos at 90deg angle, either in L or V configuration." },
mixerElevatorDirection = { t="Elevator Control Direction", help="Depending on the elevator servo position and the head design, the direction may be reversed." },
mixerAileronDirection = { t="Aileron Control Direction", help="Depending on the aileron servo position and the head design, the direction may be reversed." },
mixerCollectiveDirection = { t="Collective Control Direction", help="Depending on the blade grip control arm position, the collective direction may be reversed. Usually trailing edge control has reversed direction." },
mixerCyclicCalibration = { t="Cyclic calibration [%]", help="Adjust the cyclic gain to match the mechanical gain in the head design.", units="%" },
mixerCollectiveCalibration = { t="Collective calibration [%]", help="Adjust the collective gain to match the mechanical gain in the head design.", units="%" },
mixerCollectiveGeoCorrection = { t="Collective Geometry Correction [%]", help="Adjust until the collective positive and negative deflections are equal.", units="%" },
mixerTotalPitchLimit = { t="Total blade pitch limit [deg]", help="Maximum amount of total cyclic + collective blade pitch.", units="deg" },
mixerCyclicLimit = { t="Cyclic blade pitch limit [deg]", help="Maximum amount of cyclic blade pitch.", units="deg" },
mixerCollectiveLimit = { t="Collective blade pitch limit [deg]", help="Maximum amount of collective blade pitch.", units="deg" },
mixerSwashRing = { t="Swashring", help="The swashring limits the maximum angle the swashplate can reach in order to prevent binding. Pitch and Roll axis should be configured individually (via the Mixer input and scaling) to the desired pitch angles (without binding). If however, both the maximum Pitch and Roll are commanded <strong>at the same time</strong>, the Swashplate will have to deflect to a larger angle than either axis individually. This may result in the swashplate binding on the main shaft.<br><br>Increasing the value of Swashring will limit the maximum Swashplate angle when both Pitch and Roll are maximum." },
mixerSwashPhase = { t="Swashplate phase angle [deg]", help="The phase offset for the swashplate controls.", units="deg" },
mixerTailRotorMode = { t="Tail rotor type", help="<strong>Variable pitch:</strong> Variable pitch tail controlled by a tail servo (Servo#4). <br><strong>Motorised:</strong> The tail has a separate motor (Motor#2) for controlling the yaw.<br><strong>Bi-directional:</strong> Motorised tail operating in bi-directional mode (experimental)." },
mixerTailRotorDirection = { t="Yaw Control Direction", help="Depending on the tail rotor direction and ESC/servo configuration, the yaw direction may be reversed." },
mixerTailRotorCalibration = { t="Yaw calibration [%]", help="Adjust the yaw gain to match the mechanical gain. Usually around 50-150% for servo driven tails, but can be wildly different for motorised tail rotors.", units="%" },
mixerTailRotorMinYaw = { t="CW Yaw Blade Angle Limit", help="An angle limit for clockwise yaw." },
mixerTailRotorMaxYaw = { t="CCW Yaw Blade Angle Limit", help="An angle limit for counter-clockwise yaw." },
mixerTailMotorMinYaw = { t="CW yaw limit [%]", help="A limit for clockwise yaw.", units="%" },
mixerTailMotorMaxYaw = { t="CCW yaw limit [%]", help="A limit for counter-clockwise yaw.", units="%" },
mixerTailMotorIdle = { t="Motor idle throttle [%]", help="This is the minimum throttle signal sent to the tail motor. This should be set just high enough that the motor does not stop", units="%" },
mixerTailRotorCenterTrim = { t="Center trim for tail rotor [deg]", help="Set tail rotor trim to achieve zero blade pitch with 0° yaw mixer override.", units="deg" },
mixerTailMotorCenterTrim = { t="Center trim for tail motor [%]", help="Set tail motor throttle value for zero yaw command.", units="%" },
mixerInputChannels = { t="Mixer Control Inputs", help="<strong>Note! This is the right place to limit your controls</strong><br><br>The mixer input rate is for setting the scaling factors to match the mechanical head setup. As every rotor head is different, different scaling values are needed for each setup. <br><strong>Control:</strong> This column contains each of the Stabilized control functions. <br><strong>Minimum:</strong> Set the minimum angle you wish the blade to reach when commanded. <br><strong>Maximum:</strong> Set the maximum angle you wish the blade to reach when commanded. <br><strong>Scaling:</strong> Increase or decrease the scaling value until the helicopter blades match the commanded angle. <br><br><strong>Mixer Input Calibration Process</strong><br><strong>Step 1: </strong>Enable the mixer override by the selector on the 'SYSTEM' tab. The Mixer Override entry will now be visible on this page. <br><strong>Step 2: </strong>Enable the bypass on the Control to be calibrated. <br><strong>Step 3: </strong>Set the Mixer override to an angle (say 10 degrees). <br><strong>Step 4: </strong>Measure the actual blade angle.<br><strong>Step 5: </strong>Set the scaling so the physical blade angle matches the commanded angle." },
mixerOverride = { t="Mixer Override", help="This feature is used for setting up the rotor and is part of the <strong>Mixer Calibration</strong> process. When the bypass enable is active the mixer can be commanded to the requested positions directly." },
motorsEscProtocol = { t="ESC Throttle protocol", help="Select your ESC protocol.<br>Traditional helicopter ESCs use PWM. Drone ESCs may use other protocols, like DSHOT. <br>Make sure the protocol is supported by your ESC." },
motorsEscTelemetryProtocol = { t="ESC Telemetry protocol", help="Select your ESC Telemetry protocol. The telemetry is transmitted via a separate wire from the ESC." },
motorsUnsyncedPwm = { t="Unsyncronised ESC update", help="ESC PWM is running unsyncronised, separate from the PID loop, at the specified frequency." },
motorsUnsyncedPWMFreq = { t="ESC update frequency", help="ESC PWM update frequency in Hz. This is how often the throttle value is sent to the ESC. Usually between 50Hz and 250Hz. Most modern ESCs work fine with 250Hz." },
motorsDshotBidir = { t="DShot RPM Telemetry", help="The ESC RPM is sent back to the FC with DShot. <br>Note: Requires a compatible ESC, like BLHeli32, Bluejay or AM32." },
motorsRPMSensor = { t="RPM Sensor", help="Use the RPM Sensor input for motor RPM. You can connect an RPM signal from the ESC, or from an external RPM Sensor dongle." },
motorsMainRotorGearRatio = { t="Main Rotor Gear Ratio", help="Gear ratio between the motor and the main rotor.<br>Use <span class='value'>motor pinion</span> : <span class='value'>main gear</span> tooth count." },
motorsTailRotorGearRatio = { t="Tail Rotor Gear Ratio", help="Gear ratio between the tail rotor and the main rotor. Use <span class='value'>tail gear</span> : <span class='value'>autorotation gear</span> tooth count for Torque Tube, or <span class='value'>tail pulley</span> : <span class='value'>front pulley</span> for a belt tail. For a direct drive tail, use <span class='value'>1</span> : <span class='value'>1</span>" },
motorsThrottleMinimum = { t="0% Throttle PWM value", help="This PWM value is sent to the ESC/servo at low throttle (idle throttle with ICE)." },
motorsThrottleMaximum = { t="100% Throttle PWM value", help="This PWM value is sent to the ESC/servo at full throttle." },
motorsThrottleMinimumCommand = { t="Motor Stop Throttle PWM value", help="This PWM value is sent to the ESC/servo when the motor is stopped. This is also a value that allows the ESC to arm." },
govMode = { t="Governor mode", help="<strong>OFF:</strong> Govenor is disabled and the throttle from the Tx is passed through to the ESC.<br><br><strong>PASSTHROUGH:</strong> Throttle passthrough from the Tx, with slow spoolup and autorotation control.<br><br><strong>STANDARD:</strong> Motor speed is controlled by the FC. Equivalent to a typical ESC Governor.<br><br><strong>MODE1:</strong> Like STANDARD but with Collective and Cyclic Precompensation (i.e. collective changes are proactively changing the throttle, just like a throttle curve in the Tx).<br><br><strong>MODE2:</strong> Like MODE1, but with proactive battery voltage sag compensation. Requires fast voltage measurement." },
govHandoverThrottle = { t="Handover throttle [%]", help="The throttle level above which the governor is activated. Below this level the input throttle is passed to the ESC - above this level the governor is enabled and the input throttle is used for calculating the target headspeed. The motor must be able to start below this throttle level.", units="%" },
govStartupTime = { t="Startup time", help="Time constant for slow startup, in seconds, measuring the time from zero to full headspeed." },
govSpoolupTime = { t="Spoolup time", help="Time constant for slow spoolup, in seconds, measuring the time from zero to full headspeed." },
govTrackingTime = { t="Tracking time", help="Time constant for headspeed changes, in seconds, measuring the time from zero to full headspeed." },
govRecoveryTime = { t="Recovery time", help="Time constant for recovery spoolup, in seconds, measuring the time from zero to full headspeed." },
govAutoBailoutTime = { t="Autorotation bailout time", help="Time constant for autorotation bailout spoolup, in seconds, measuring the time from zero to full headspeed." },
govAutoTimeout = { t="Autorotation timeout", help="Timeout for ending autorotation and moving to normal IDLE." },
govAutoMinEntryTime = { t="Autorotation minimum entry time", help="Minimum flight time before autorotation can be engaged." },
govZeroThrottleTimeout = { t="Zero Throttle timeout", help="Timeout for missing (zero) throttle signal, before shutting down the governor. If the throttle signal returns within this timeout, the governor will perform a recovery spoolup." },
govLostHeadspeedTimeout = { t="Headspeed signal timeout", help="Timeout for missing headspeed signal, before spooling down. If the RPM signal returns within this timeout, the governor will perform a recovery spoolup." },
govHeadspeedFilterHz = { t="Headspeed filter cutoff [Hz]", help="Cutoff for the headspeed lowpass filter.", units="Hz" },
govVoltageFilterHz = { t="Battery voltage filter cutoff [Hz]", help="Cutoff for the battery voltage lowpass filter.", units="Hz" },
govTTAFilterHz = { t="TTA Bandwidth [Hz]", help="Cutoff for the TTA lowpass filter.", units="Hz" },
govFFFilterHz = { t="Precomp Bandwidth [Hz]", help="Cutoff for the cyclic/collective precompensation lowpass filter.", units="Hz" },
govHeadspeed = { t="Full headspeed", help="The governor target headspeed is calculated by multiplying the full headspeed with the throttle input." },
govMaxThrottle = { t="Maximum Throttle", help="Maximum output throttle the governor is allowed to use." },
govMasterGain = { t="PID master gain", help="Master PID loop gain. Usually 10..100" },
govPGain = { t="P-gain", help="PID loop P-term gain. Usually 10..100" },
govIGain = { t="I-gain", help="PID loop I-term gain. Usually 10..100" },
govDGain = { t="D-gain", help="PID loop D-term gain. Usually 0..100" },
govFGain = { t="Feedforward gain", help="Collective/Cyclic feedforward gain. Usually 0..100" },
govTTAGain = { t="Tail Torque Assist (TTA) gain", help="Tail Torque Assist strength (gain). This is a gain applied to increase the headspeed to control the tail in the negative direction (e.g. Motorised tail less than idle speed). Usually 50..150" },
govTTALimit = { t="Tail Torque Assist (TTA) limit [%]", help="Tail Torque Assist maximum Headspeed increase. This sets an upper limit how much the headspeed can go over the Full Headspeed. Usually 20..50%.", units="%" },
govYawPrecomp = { t="Yaw precompensation", help="Yaw precompensation weight. Determines how much Yaw is mixed into the feedforward. This helps the governor to maintain the headspeed proactively. Usually 20..100" },
govCyclicPrecomp = { t="Cyclic precompensation", help="Cyclic precompensation weight. Determines how much cyclic is mixed into the feedforward. This helps the governor to maintain the headspeed proactively. Usually 20..100" },
govCollectivePrecomp = { t="Collective precompensation", help="Collective precompensation weight. Determines how much collective is mixed into the feedfoward. This helps the governor to maintain the headspeed proactively. Usually 20..100" },
profilesErrorLimit = { t="Cumulative Error Limits", help="Hard limit for the angle error in the PID loop. The absolute error and thus the I-term will never go above these limits." },
profilesErrorLimitRoll = { t="Error Limit for Roll Axis [deg]", help="Hard limit for the angle error in the PID loop. The absolute error and thus the I-term will never go above these limits.", units="deg" },
profilesErrorLimitPitch = { t="Error Limit for Pitch Axis [deg]", help="Hard limit for the angle error in the PID loop. The absolute error and thus the I-term will never go above these limits.", units="deg" },
profilesErrorLimitYaw = { t="Error Limit for Yaw Axis [deg]", help="Hard limit for the angle error in the PID loop. The absolute error and thus the I-term will never go above these limits.", units="deg" },
profilesOffsetLimitRoll = { t="HSI Offset Limit for Roll Axis [deg]", help="Hard limit for the High Speed Integral offset angle in the PID loop. The absolute offset and thus the O-term will never go above these limits.", units="deg" },
profilesOffsetLimitPitch = { t="HSI Offset Limit for Pitch Axis [deg]", help="Hard limit for the High Speed Integral offset angle in the PID loop. The absolute offset and thus the O-term will never go above these limits.", units="deg" },
profilesOffsetGainRoll = { t="HSI Offset Gain for Roll Axis", help="Gain for the High Speed Integral Offset term (Integral for high speed flight), which is only active at large collective angles. This term of the control loop provides angular stability and safe control following at high speeds, as well as attitude stability on large changes of the collective pitch angle of the rotor disk, which would lead to rapid diving and unwanted attitude changes without HSI. Too low values cause the model to become unstable at high speeds, as well as slow reaction and large attitude changes on collective pitch changes. Too large values can cause oscillation and restlessness at large collective pitch angles. For testing of the lower bounds of the parameter, fly in a straight line <strong> AT SAFE ALTITUDE</strong>, only briefly pull the collective into the negative range and observe the model's reaction. Should the model dive, increase the HSI Offset Gain. For testing the upper bounds of the parameter, give short jabs of elevator and aileron in a high collective vertical climb and observe the model's behavior. If the model swings, wobbles or exerts restlessness after releasing the stick, decrease the HSI Offset Gain." },
profilesOffsetGainPitch = { t="HSI Offset Gain for Pitch Axis", help="Gain for the High Speed Integral Offset term (Integral for high speed flight), which is only active at large collective angles. This term of the control loop provides angular stability and safe control following at high speeds, as well as attitude stability on large changes of the collective pitch angle of the rotor disk, which would lead to rapid diving and unwanted attitude changes without HSI. Too low values cause the model to become unstable at high speeds, as well as slow reaction and large attitude changes on collective pitch changes. Too large values can cause oscillation and restlessness at large collective pitch angles. For testing of the lower bounds of the parameter, fly in a straight line <strong> AT SAFE ALTITUDE</strong>, only briefly pull the collective into the negative range and observe the model's reaction. Should the model dive, increase the HSI Offset Gain. For testing the upper bounds of the parameter, give short jabs of elevator and aileron in a high collective vertical climb and observe the model's behavior. If the model swings, wobbles or exerts restlessness after releasing the stick, decrease the HSI Offset Gain." },
profilesErrorDecayTimeCyclic = { t="Error Decay time [s]", help="Time constant for bleeding off the accumulated cyclic error (I-term). Longer decay time makes hovering more stable, but may reduce 3D performance.", units="s" },
profilesErrorDecayLimitCyclic = { t="Error Decay maximum rate [deg/s]", help="Maximum bleed-off speed for the accumulated cyclic error (I-term).", units="deg/s" },
profilesErrorDecayTimeYaw = { t="Error Decay time [s]", help="Time constant for bleeding off the accumulated yaw error (I-term).", units="s" },
profilesErrorDecayLimitYaw = { t="Error Decay maximum rate [deg/s]", help="Maximum bleed-off speed for the accumulated yaw error (I-term).", units="deg/s" },
profilesErrorRotation = { t="Piro Compensation", help="Rotates the current Roll and Pitch Error Terms around Yaw when the craft rotates. This improves piro control and helps the model to travel in a straight line while pirouetting." },
profilesItermRelax = { t="I-Term Relax", help="Limits the accumulation of I-term when fast movements happen. This helps in the reduction of bounceback at the end of rolls and other fast movements." },
profilesItermRelaxType = { t="I-term Relax Type", help="Choose the axes in which this is active. <br><strong>RP:</strong> Roll, Pitch <br><strong>RPY:</strong> Roll, Pitch, Yaw." },
profilesItermRelaxCutoffRoll = { t="Cutoff Point for Roll", help="Lower values suppress bounce-back after movements, high values increase high-rate turn precision.<br>Set to 15-30 for small helis, 10-15 for mid-size, and less than 10 for large." },
profilesItermRelaxCutoffPitch = { t="Cutoff Point for Pitch", help="Lower values suppress bounce-back after movements, high values increase high-rate turn precision.<br>Set to 15-30 for small helis, 10-15 for mid-size, and less than 10 for large." },
profilesItermRelaxCutoffYaw = { t="Cutoff Point for Yaw", help="Lower values suppress bounce-back after movements, high values increase high-rate turn precision.<br>Set to 15-30 for small helis, 10-15 for mid-size, and less than 10 for large." },
profilesGyroCutoffRoll = { t="Roll Bandwidth", help="PID Loop overall bandwidth in Hz" },
profilesGyroCutoffPitch = { t="Pitch Bandwidth", help="PID Loop overall bandwidth in Hz" },
profilesGyroCutoffYaw = { t="Yaw Bandwidth", help="PID Loop overall bandwidth in Hz" },
profilesDtermCutoffRoll = { t="Roll D-term Cutoff", help="D-term Cutoff Frequency in Hz" },
profilesDtermCutoffPitch = { t="Pitch D-term Cutoff", help="D-term Cutoff Frequency in Hz" },
profilesDtermCutoffYaw = { t="Yaw D-term Cutoff", help="D-term Cutoff Frequency in Hz" },
profilesBtermCutoffRoll = { t="Roll B-term Cutoff", help="B-term Cutoff Frequency in Hz" },
profilesBtermCutoffPitch = { t="Pitch B-term Cutoff", help="B-term Cutoff Frequency in Hz" },
profilesBtermCutoffYaw = { t="Yaw B-term Cutoff", help="B-term Cutoff Frequency in Hz" },
profilesAcroTrainerGain = { t="Acro Trainer gain", help="Acro trainer Mode is not self leveling but does limit the maximum pitch/roll angle. This determines how aggressively the helicopter tilts back to the maximum angle (if exceeded) while in Acro Trainer Mode" },
profilesAcroTrainerLimit = { t="Acro Trainer angle limit", help="Acro Trainer mode does not self level (like Angle or Horizon Modes); however, it does limit the maximum angle the helicopter will pitch/roll to" },
profilesAngleModeGain = { t="Angle Mode leveling gain", help="This determines how aggressively the helicopter tilts back to level while in Angle Mode" },
profilesAngleModeLimit = { t="Angle Mode maximum angle", help="Helicopter is limited to this angle when in Angle mode" },
profilesHorizonModeGain = { t="Horizon Mode leveling gain", help="This determines how aggressively the helicopter tilts back to level while in Horizon Mode" },
profilesYawCenterOffset = { t="Center Offset", help="Center Offset for tail motor or servo" },
profilesYawStopGainCW = { t="CW Yaw Stop Gain", help="Stop gain (PD) for clock-wise rotation. Typical range 50..200." },
profilesYawStopGainCCW = { t="CCW Yaw Stop Gain", help="Stop gain (PD) for counter clock-wise rotation. Typical range 50..200." },
profilesYawPrecompCutoff = { t="Yaw Precomp Cutoff [Hz]", help="Frequency limit for all yaw precompensation actions", units="Hz" },
profilesYawFFCyclicGain = { t="Cyclic Feedforward Gain", help="Gain value for cyclic feedforward mixed into yaw" },
profilesYawFFCollectiveGain = { t="Collective Feedforward Gain", help="Gain value for collective feedforward mixed into yaw" },
profilesYawFFImpulseGain = { t="Collective Impulse Feedforward Gain", help="Gain value for collective impulse feedforward mixed into yaw" },
profilesyawFFImpulseDecay = { t="Collective Impulse Feedforward Decay time", help="Decay time for collective impulse feedforward mixed into yaw" },
profilesPitchFFCollective = { t="Collective to Pitch Compensation", help="Compensation for the pitching up tendency in collective pitch pumps." },
profilesPitchFFCollectiveGain = { t="Compensation Gain", help="Amount of collective mixed into the elevator control." },
profilesCyclicCrossCoupling = { t="Cyclic Cross-Coupling", help="Cyclic Cross-Coupling compensation removes the aileron (roll) wobble when only elevator is applied." },
profilesCyclicCrossCouplingGain = { t="Cross-Coupling Gain", help="Amount of compensation applied for Pitch-to-Roll decoupling." },
profilesCyclicCrossCouplingRatio = { t="Cross-Coupling Ratio [%]", help="Amount of Roll-to-Pitch compensation needed, vs. Pitch-to-Roll.", units="%" },
profilesCyclicCrossCouplingCutoff = { t="Cross-Coupling Cutoff Frequency [Hz]", help="Frequency limit for the compensation. Higher value will make the compensation action faster.", units="Hz" },
profilesRescueFlipMode = { t="Flip to upright", help="If rescue is activated while inverted, flip to upright - or remain inverted" },
profilesRescueLevelGain = { t="Leveling Gain", help="Gain to determine how agressively the heli levels during rescue." },
profilesRescueFlipGain = { t="Flip-to-Upright Gain", help="Gain to determine how agressively the heli flips during inverted rescue." },
profilesRescueMaxRate = { t="Max Levelling Rate [deg/s]", help="Limit rescue roll/pitch rate. Larger helicopters may need slower rotation rates.", units="deg/s" },
profilesRescueMaxAccel = { t="Max Leveling Acceleration [deg/s²]", help="Limit how fast the helicopter accelerates into a roll/pitch. Larger helicopters may need slower acceleration.", units="deg/s²" },
profilesRescuePullupCollective = { t="Pull-up Collective [%]", help="Collective value for pull-up climb.", units="%" },
profilesRescuePullupTime = { t="Pull-up Time [s]", help="Rescue pull-up time. When Rescue activated Helicopter will apply pull-up collective for this time period before moving to flip or climb stage.", units="s" },
profilesRescueClimbCollective = { t="Climb Collective [%]", help="Collective value for rescue climb", units="%" },
profilesRescueClimbTime = { t="Climb Time [s]", help="Length of time the <i>climb collective</i> is applied before switching to hover.", units="s" },
profilesRescueHoverCollective = { t="Hover Collective [%]", help="Collective value for Hover", units="%" },
profilesRescueExitTime = { t="Exit Time [s]", help="Collective is rate limited during this period to provide smooth transition to normal flight. This limits rapid application of negative collective if the Helicopter has rolled during rescue", units="s" },
profilesRescueFlipTime = { t="Flip Fail Time [s]", help="Timeout for flip failure. If the helicopter is in rescue and is trying to flip to upright and does not do with the Rescue Flip Time, rescue will be aborted", units="s" },
profilesRescueHoverAltitude = { t="Hover Altitude [m]", help="Hovering altitude after rescue action", units="m" },
profilesRescueAltitudePGain = { t="Altitude P-Gain", help="P-gain for altitude control" },
profilesRescueAltitudeIGain = { t="Altitude I-Gain", help="I-gain for altitude control" },
profilesRescueAltitudeDGain = { t="Altitude D-Gain", help="D-gain for altitude control (vario)" },
profilesRescueMaxCollective = { t="Maximum Collective [%]", help="Maximum Collective to apply for altitude control", units="%" },
gyroDynamicNotchCount = { t="Dynamic Notch Count", help="Select the number of dynamic notch filters. If used standalone without the RPM filters, 4-6 is recommended. With the RPM filters, 2-4 is recommended." },
gyroDynamicNotchQ = { t="Dynamic Notch Q", help="The Q factor adjusts how wide the dynamic notch filters are. A higher value makes it narrower and more selective, and a lower value makes it wider and broader. Values between 2.0 and 4.0 are recommended. A value lower than 2.0 will greatly increase filter delay and may degrade flight performance." },
gyroDynamicNotchMinHz = { t="Dynamic Notch Minimum Frequency", help="Set this to the lowest incoming noise frequency that is needed to be filtered. Should be lower than main rotor frequency, but no lower that 20Hz, which is eqivalent to 1200rpm." },
gyroDynamicNotchMaxHz = { t="Dynamic Notch Maximum Frequency", help="Set this to the highest incoming noise frequency that is needed to be filtered. Should be 10-20% higher than the max tail rotor frequency, but no higher than 250Hz, if filter rate is 1k. If filter rate is 2k or higher, then 330-500 Hz can be used, especially for smaller helis with a motorised tail (higher range means less precision and lower performance)." },
gyroRpmFilterMainRotorMinRPM = { t="Main Rotor Minimum Filtered RPM", help="Minimum Main Rotor RPM accepted by the filters" },
gyroRpmFilterTailRotorMinRPM = { t="Tail Rotor Minimum Filtered RPM", help="Minimum Tail Rotor RPM accepted by the filters" },
vtxFrequencyChannel = { t="Enter frequency directly", help="If you enable this, the Configurator will let you select a frequency in place of the habitual band/channel. For this to work your VTX must support this feature." },
vtxBand = { t="Band", help="You can select here the band for your VTX" },
vtxChannel = { t="Channel", help="You can select here the channel for your VTX" },
vtxFrequency = { t="Frequency", help="You can select here the frequency for your VTX if it is supported" },
vtxPower = { t="Power", help="This is the power selected for the VTX. It can be modified if the $t(vtxPitMode.message) or the $t(vtxLowPowerDisarm.message) is enabled" },
vtxPitMode = { t="Pit Mode", help="When enabled, the VTX enters in a very low power mode to let the quad be on at the bench without disturbing other pilots. Usually the range of this mode is less than 5m.<br /><br />NOTE: Some protocols, like SmartAudio, can't enable Pit Mode via software after power-up." },
vtxPitModeFrequency = { t="Pit Mode frequency", help="Frequency at which the Pit Mode changes when enabled." },
vtxLowPowerDisarm = { t="Low Power Disarm", help="When enabled, the VTX uses the lowest available power when disarmed (except if a failsafe has occurred)." },
vtxTablePowerLevels = { t="Number of power levels", help="This defines the number of power levels supported by your VTX" },
configurationPidProcessDenom = { t="PID loop frequency", help="The maximum frequency for the PID loop is limited by the CPU processing power. The Realtime Load should not exceed 70% with the selected loop speed." },
configurationGyroUse32kHz = { t="Enable gyro 32kHz sampling mode", help="32 kHz gyro update frequency is only possible if the gyro chip supports it (currently MPU6500, MPU9250, and ICM20xxx if connected over SPI). If in doubt, consult the specification for your board." },
configurationAccHardware = { t="Accelerometer", help="Enables the Accelerometer. This is required for all stabilisation modes: Angle, Horizon, Acro Trainer and Rescue." },
configurationBaroHardware = { t="Barometer", help="Enables the Barometer (if available). Altitude is currently not used in Flight Control. It is informative only, available via the Telemetry." },
configurationMagHardware = { t="Magnetometer", help="Enables the Magnetometer (if available). Compass direction is currently not used in Flight Control. It is informative only, available via the Telemetry." },
blackboxMode = { t="Logging mode", help="<strong>OFF:</strong> Disable logging.<br><br><strong>NORMAL:</strong> Enable logging when both ARMED and BLACKBOX switch are active.<br><br><strong>ARMED:</strong> Enable logging when ARMED.<br><br><strong>SWITCH:</strong> Enable logging when BLACKBOX switch is active." },
blackboxDevice = { t="Logging device", help="<strong>No Logging:</strong> Disable logging.<br><br><strong>Onboard Flash:</strong> Log to the onboard flash chip (if available).<br><br><strong>SD Card:</strong> Log to the onboard SD card (if available).<br><br><strong>Serial Port:</strong> Log to an external logger device (e.g OpenLager) connected to a serial port. The serial port must to be configured to 'Blackbox Logging' on the <strong>Configuration</strong> tab." },
blackboxRateOfLogging = { t="Logging rate", help="The log data is saved to the log device with this rate. For logging to an external device, lower speed may be required." },
blackboxDebugMode = { t="Debug mode", help="Choose what <i>extra</i> data is being logged. If enabled, eight extra debug items are added to the Blackbox Log." },
blackboxDebugAxis = { t="Debug axis", help="Choose which <i>axis</i> is being debugged. Applies to some of the debug modes." },
}